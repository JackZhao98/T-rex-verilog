#!/usr/bin/env python

# img2fmem.py - image to FPGA memory map converter
# By Will Green - https://timetoexplore.net
# Copyright (c) 2018, Will Green, Licensed under BSD 3-Clause License
# For latest version and docs visit https://github.com/WillGreen/fpgatools

import os
import sys
from PIL import Image

if len(sys.argv) != 4:
    print("usage: python img2fmem.py image_file colour_bits output_format")
    print("       image_file: source image file name")
    print("       colour_bits: number of colour bits per pixel: 4, 6, or 8")
    print("       output_format: mem or coe")
    sys.exit()

MESSAGE = "Generated by img2fmem.py - https://github.com/WillGreen/fpgatools\n"

input_file = sys.argv[1]
base_name = os.path.splitext(input_file)[0]

colour_bits = int(sys.argv[2])
if colour_bits == 4:
    pal_size = 16
elif colour_bits == 6:
    pal_size = 64
else:
    pal_size = 256  # default to 8-bit
    colour_bits = 8  # explictly assign a value so we can use in COE format

output_format = sys.argv[3]

# load source image
source_img = Image.open(input_file)
prev_img = source_img.copy()  # take a copy for later preview process
(width, height) = source_img.size

# Reduce to 12-bit precision (4-bit per colour) in range 0-15
pixels = source_img.load()
for x in range(width):
    for y in range(height):
        pixels[x, y] = tuple([p // 16 for p in pixels[x, y]])

# Convert to limited colour palette
dest_img = source_img.convert('P', palette=Image.ADAPTIVE, colors=pal_size)
dest_pal = dest_img.palette.palette

# Generate hex image output
image_data = dest_img.getdata()
image_output = ''
if output_format == 'mem':
    image_output += "// " + MESSAGE
    for d in image_data:
        image_output += hex(d)[2:] + "\n"
elif output_format == 'coe':
    image_output += "; " + MESSAGE
    image_output += "memory_initialization_radix={:d};".format(colour_bits)
    image_output += "\nmemory_initialization_vector=\n"
    for d in image_data:
        image_output += hex(d)[2:] + ",\n"
    # replace last comma with semicolon to complete coe statement
    image_output = image_output[:-2]
    image_output += ";\n"
else:
    print("Error: output_format should be mem or coe.")
    sys.exit()

with open(base_name + '.' + output_format, 'w') as f:
    f.write(image_output)

# Chunk raw palette into three byte sections (RGB)
colours = [bytearray(dest_pal[i:i+3]) for i in range(0, len(dest_pal), 3)]

# Generate hex palette output
palette_output = ''
if output_format == 'mem':
    palette_output += "// " + MESSAGE
    for i in range(pal_size):
        pal_entry = colours[i][0] * 256 + colours[i][1] * 16 + colours[i][2]
        palette_output += hex(pal_entry)[2:] + "\n"
elif output_format == 'coe':
    palette_output += "; " + MESSAGE
    palette_output += "memory_initialization_radix=12;\n"
    palette_output += "memory_initialization_vector=\n"
    for i in range(pal_size):
        pal_entry = colours[i][0] * 256 + colours[i][1] * 16 + colours[i][2]
        palette_output += hex(pal_entry)[2:] + ",\n"
    # replace last comma with semicolon to complete coe statement
    palette_output = palette_output[:-2]
    palette_output += ";\n"
else:
    print("Error: output_format should be mem or coe.")
    sys.exit()

with open(base_name + '_palette.' + output_format, 'w') as f:
    f.write(palette_output)

# Convert preview image and save
# 4-bit per pixel but retain full 0-255 range so image is not too dark
prev_pixels = prev_img.load()
for x in range(width):
    for y in range(height):
        prev_pixels[x, y] = tuple([(p // 16) * 16 for p in prev_pixels[x, y]])
prev_img = prev_img.convert('P', palette=Image.ADAPTIVE, colors=pal_size)
prev_img.save(base_name + '_preview.png')
